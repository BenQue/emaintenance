#!/bin/bash

# Pre-commit hook for E-Maintenance project
# This hook runs quality checks before allowing commits

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    echo -e "${BLUE}[PRE-COMMIT]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log "Running pre-commit checks..."

# Get the root directory
PROJECT_ROOT="$(git rev-parse --show-toplevel)"
cd "$PROJECT_ROOT"

# Check if we have staged files
if git diff --cached --quiet; then
    log "No staged changes, skipping pre-commit checks"
    exit 0
fi

# Check for secrets or sensitive information
log "Checking for secrets and sensitive information..."
SECRETS_FOUND=false

# Define patterns to search for
SECRET_PATTERNS=(
    "password.*=.*['\"].*['\"]"
    "secret.*=.*['\"].*['\"]"
    "token.*=.*['\"].*['\"]"
    "api.*key.*=.*['\"].*['\"]"
    "private.*key"
    "BEGIN PRIVATE KEY"
    "BEGIN RSA PRIVATE KEY"
    "BEGIN OPENSSH PRIVATE KEY"
)

for pattern in "${SECRET_PATTERNS[@]}"; do
    if git diff --cached --name-only | xargs grep -l -i "$pattern" 2>/dev/null; then
        error "Potential secret found matching pattern: $pattern"
        SECRETS_FOUND=true
    fi
done

# Check for hardcoded credentials in specific patterns
if git diff --cached | grep -i "password.*=.*['\"][^'\"]*['\"]" | grep -v "placeholder\|example\|test\|demo"; then
    error "Hardcoded password detected in staged changes"
    SECRETS_FOUND=true
fi

if [[ "$SECRETS_FOUND" == "true" ]]; then
    error "Secrets or sensitive information detected. Please remove them before committing."
    exit 1
fi

# Run linting on staged files
log "Running ESLint on staged files..."
STAGED_TS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(ts|tsx|js|jsx)$' || true)

if [[ -n "$STAGED_TS_FILES" ]]; then
    if ! npm run lint -- $STAGED_TS_FILES; then
        error "ESLint checks failed. Please fix the issues before committing."
        exit 1
    fi
    success "ESLint checks passed"
else
    log "No TypeScript/JavaScript files to lint"
fi

# Run type checking if TypeScript files are staged
if [[ -n "$STAGED_TS_FILES" ]]; then
    log "Running TypeScript type checking..."
    if command -v tsc >/dev/null 2>&1; then
        if ! npx tsc --noEmit; then
            error "TypeScript type checking failed. Please fix the type errors before committing."
            exit 1
        fi
        success "TypeScript type checking passed"
    else
        warning "TypeScript compiler not found, skipping type checking"
    fi
fi

# Check for console.log statements in production code
log "Checking for console.log statements..."
CONSOLE_LOGS_FOUND=false

for file in $STAGED_TS_FILES; do
    if [[ -f "$file" ]] && grep -q "console\.\(log\|error\|warn\|info\)" "$file"; then
        # Skip test files and development-specific files
        if [[ ! "$file" =~ \.(test|spec)\.(ts|tsx|js|jsx)$ ]] && [[ ! "$file" =~ /test/ ]] && [[ ! "$file" =~ /tests/ ]]; then
            warning "Console statement found in $file"
            CONSOLE_LOGS_FOUND=true
        fi
    fi
done

if [[ "$CONSOLE_LOGS_FOUND" == "true" ]]; then
    warning "Console statements found in production code. Consider using structured logging instead."
    echo "Continue anyway? (y/N): "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        exit 1
    fi
fi

# Check for TODO comments in critical files
log "Checking for TODO comments in critical files..."
TODO_FILES=$(git diff --cached --name-only | xargs grep -l "TODO\|FIXME\|XXX" 2>/dev/null | grep -E "(controller|service|repository)" || true)

if [[ -n "$TODO_FILES" ]]; then
    warning "TODO/FIXME comments found in critical files:"
    echo "$TODO_FILES"
    echo "Consider addressing these before committing to production. Continue anyway? (y/N): "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        exit 1
    fi
fi

# Check Docker files for best practices
log "Checking Docker files for best practices..."
DOCKER_FILES=$(git diff --cached --name-only | grep -E "Dockerfile|docker-compose.*\.yml$" || true)

if [[ -n "$DOCKER_FILES" ]]; then
    for file in $DOCKER_FILES; do
        if [[ -f "$file" ]]; then
            # Check for COPY instead of ADD
            if grep -q "^ADD " "$file" && ! grep -q "tar\|zip" "$file"; then
                warning "Consider using COPY instead of ADD in $file"
            fi
            
            # Check for root user
            if ! grep -q "USER " "$file" && [[ "$file" =~ Dockerfile ]]; then
                warning "No USER instruction found in $file - running as root"
            fi
            
            # Check for .dockerignore
            if [[ "$file" =~ Dockerfile ]] && [[ ! -f "$(dirname "$file")/.dockerignore" ]]; then
                warning "No .dockerignore file found for $file"
            fi
        fi
    done
fi

# Check package.json for version updates
PACKAGE_JSON_FILES=$(git diff --cached --name-only | grep "package\.json$" || true)

if [[ -n "$PACKAGE_JSON_FILES" ]]; then
    log "package.json changes detected"
    for file in $PACKAGE_JSON_FILES; do
        if git diff --cached "$file" | grep -q '"version"'; then
            success "Version updated in $file"
        else
            warning "package.json changed but version not updated in $file"
        fi
    done
fi

# Check for migration files
MIGRATION_FILES=$(git diff --cached --name-only | grep -E "migration|schema\.prisma" || true)

if [[ -n "$MIGRATION_FILES" ]]; then
    warning "Database migration files detected:"
    echo "$MIGRATION_FILES"
    warning "Ensure migrations are tested and backward compatible!"
    echo "Continue with commit? (y/N): "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        exit 1
    fi
fi

# Generate build metadata
log "Generating build metadata..."
BUILD_INFO_FILE="build-info.json"
cat > "$BUILD_INFO_FILE" << EOF
{
  "buildDate": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "gitCommit": "$(git rev-parse HEAD)",
  "gitBranch": "$(git rev-parse --abbrev-ref HEAD)",
  "gitDirty": $(git diff --quiet && echo "false" || echo "true"),
  "buildUser": "$(git config user.name)",
  "buildHost": "$(hostname)"
}
EOF

# Auto-format staged files if formatter is available
if command -v prettier >/dev/null 2>&1; then
    log "Auto-formatting staged files..."
    FORMATTABLE_FILES=$(git diff --cached --name-only | grep -E '\.(ts|tsx|js|jsx|json|md|yml|yaml)$' || true)
    
    if [[ -n "$FORMATTABLE_FILES" ]]; then
        echo "$FORMATTABLE_FILES" | xargs prettier --write
        # Re-stage formatted files
        echo "$FORMATTABLE_FILES" | xargs git add
        success "Files auto-formatted and re-staged"
    fi
fi

# Final validation
log "Running final validation..."

# Ensure no merge conflict markers
if git diff --cached | grep -E "^(<{7}|>{7}|={7})"; then
    error "Merge conflict markers found in staged files"
    exit 1
fi

# Ensure no debug statements
if git diff --cached | grep -i "debugger\|console\.trace"; then
    error "Debug statements found in staged files"
    exit 1
fi

success "All pre-commit checks passed!"

# Optional: Auto-build on significant changes
SIGNIFICANT_CHANGES=$(git diff --cached --name-only | grep -E "(Dockerfile|package\.json|\.ts$|\.tsx$)" | wc -l)

if [[ $SIGNIFICANT_CHANGES -gt 5 ]]; then
    log "Significant changes detected ($SIGNIFICANT_CHANGES files)"
    echo "Run local build to verify changes? (y/N): "
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        log "Running local build..."
        if ./local-deploy/scripts/build-images.sh --tag "pre-commit-$(date +%Y%m%d_%H%M%S)" web user-service; then
            success "Local build completed successfully"
        else
            error "Local build failed"
            echo "Continue with commit anyway? (y/N): "
            read -r response
            if [[ ! "$response" =~ ^[Yy]$ ]]; then
                exit 1
            fi
        fi
    fi
fi

log "Pre-commit checks completed successfully"
exit 0