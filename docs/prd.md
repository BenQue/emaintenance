# 产品需求文档 (PRD): 企业设备维修管理程序 v1.0

## 1. 目标和背景上下文 (Goals and Background Context)

### 目标 (Goals)

- **业务目标**: 将设备平均维修时间缩短 25%，或将因设备故障导致的生产中断减少 15%。
- **用户成功指标**: 90%的报修在一分钟内通过移动端提交，或技术人员在任务更新上的平均耗时减少 50%。
- **产品目标**: 提供一个实时的、流程驱动的 CMMS，实现维修流程的数字化和透明化，并为预防性维护提供数据基础。

### 背景上下文 (Background Context)

当前的企业设备维修流程依赖于手动的 Excel 事后记录，这导致了效率低下、信息不透明和数据追踪困难等问题。这些痛点不仅影响了日常运营效率和绩效评估，更阻碍了公司向预防性维护等高级管理策略的转型。本项目旨在通过一个以移动端为核心的 CMMS 系统，解决上述问题，推动企业数字化转型。

### 变更日志 (Change Log)

| 日期              | 版本 | 描述         | 作者     |
| ----------------- | ---- | ------------ | -------- |
| 2025 年 8 月 1 日 | 1.0  | 初始文档创建 | John, PM |
| 2025 年 9 月 27 日 | 1.1  | 工单创建流程优化：移除报修类别和原因，增加故障表现选择；位置信息自动化；优化优先级规则 | Sarah, PO |
| 2025 年 9 月 30 日 | 1.2  | 工单关闭流程增强：新增CLOSED状态；员工可查看自己创建的工单；员工需确认关闭已完成的工单 | Claude |

## 2. 需求 (Requirements)

### 功能性需求 (Functional Requirements)

- **FR1**: 系统必须允许一线员工通过移动应用（Flutter）发起设备报修请求。
- **FR2**: 报修时，应用需支持通过扫描资产码自动填充设备信息。
- **FR3**: 报修时，用户必须能上传照片/视频，并支持在照片上进行圈点标注。
- **FR4**: 报修时，用户必须能为请求设定一个优先级。
- **FR5**: 系统需能将报修请求转换为维修工单，并支持自动或手动派工给维修技术员。
- **FR6**: 维修技术员必须能在 Web 端 (React/Next.js) 和移动端查看、接收和管理分配给他们的工单。
- **FR7**: 工单详情页必须展示设备的维修历史、故障描述和附加的 SOP 文档。
- **FR8**: 维修技术员必须能实时更新工单状态（如"进行中"、"等待备件"、"已完成"）。
- **FR9**: 维修完成后，技术员必须能在工单中记录解决方案并上传完成后的照片。
- **FR10**: 系统必须为设备主管和经理提供一个 Web 端的 KPI 仪表板。
- **FR11**: KPI 仪表板必须以可视化的方式（如图表）展示工单、时间（MTTR 等）和资产相关的核心指标。

### 非功能性需求 (Non-Functional Requirements)

- **NFR1**: 移动端应用必须兼容主流的安卓 PDA 或平板设备。
- **NFR2**: Web 端应用必须兼容最新版本的 Chrome 浏览器。
- **NFR3**: 基于公司网络安全策略，只有公司内部授权的移动设备才能访问后端服务。
- **NFR4**: 系统需设计为微服务架构，并通过 Docker 进行部署。
- **NFR5**: 数据库需使用 PostgreSQL。

## 3. 用户界面设计目标 (User Interface Design Goals)

- **整体 UX 愿景**: 简洁、高效、直观。

### 核心屏幕

- **移动端**: 扫码/登录页, 发起报修表单页, 我的任务列表页, 工单详情页。
- **Web 端**: 登录页, KPI 仪表板, 工单管理列表页, 工单详情页, 设备/资产管理页。

### 品牌与无障碍设计

- **品牌**: 遵循公司 Logo 和指定的公司蓝色基调。
- **无障碍设计**: 遵循 WCAG AA 标准。

## 4. 技术假设 (Technical Assumptions)

- **仓库结构**: Monorepo（单一代码库）。
- **服务架构**: 微服务架构，通过 Docker 容器化部署。
- **测试要求**: 单元测试与集成测试相结合。

### 技术栈

- **前端 (Web)**: React / Next.js + ShadCN/UI。
- **移动端 (Mobile)**: Flutter。
- **后端 (Backend)**: Node.js + Prisma ORM + PostgreSQL。

## 5. 史诗列表 (Epic List)

### 史诗 1: 基础架构与核心报修流程

**目标**: 建立项目的基础架构，实现基础的用户和角色管理，完成设备主数据的初始化，并实现一线员工通过移动端提交维修请求的核心流程。

### 史诗 2: 工单管理与处理

**目标**: 实现维修工单的自动化分配、接收和状态更新，让维修技术员可以高效地处理任务并归档解决方案。

### 史诗 3: KPI 仪表板与管理视图

**目标**: 为管理层提供一个可视化的 KPI 仪表板，并提供完善的用户和设备主数据管理界面，以支持数据驱动的决策和日常管理。

### 史诗 4: Web 端用户登录界面

**目标**: 为 Web 应用实现登录界面，使用户能够通过已有的后端认证系统进行身份验证，获取 JWT token 并访问受保护的系统功能。

## 6. 史诗详情 (Epic Details)

### 史诗 1: 基础架构与核心报修流程

**目标**: 这个史诗的目标是搭建整个项目的技术地基，并交付一个完整的、最小化的核心产品闭环：一个用户可以注册登录，看到设备并成功提交一个维修请求。完成后，我们将拥有一个可以运行的、包含核心数据的系统骨架。

#### 故事 1.1: 项目初始化与技术栈搭建

**作为一个** 开发人员,

**我想要** 一个配置好的 Monorepo 代码仓库，其中包含前端(Next.js)、后端(Node.js)和移动端(Flutter)的应用骨架,

**以便于** 我可以在一个一致和标准化的环境中开始功能开发。

**验收标准**:

- Monorepo 仓库已使用指定工具初始化。
- Web、API 和 Mobile 三个独立的应用/包已创建。
- 数据库(PostgreSQL)连接已通过 Prisma ORM 配置成功。
- 基础的 Linting 和格式化规则已配置。

#### 故事 1.2: 用户认证与角色管理

**作为一个** 用户 (员工、技术员、主管),

**我想要** 能够注册和登录系统,

**以便于** 系统可以识别我的身份并授予我相应角色的访问权限。

**验收标准**:

- 提供用户注册和登录的 API 端点。
- 用户数据（包括加密后的密码）能被安全地存储在数据库中。
- 系统需包含至少三种角色：员工、技术员、主管。
- 登录成功后，系统返回一个用于身份验证的凭证 (Token)。

#### 故事 1.3: 核心主数据管理 API

**作为一个** 系统管理员,

**我想要** 能够通过 API 对核心主数据（特别是设备清单）进行增、删、改、查操作,

**以便于** 为系统的正常运作提供必要的初始数据。

**验收标准**:

- 提供针对"设备/资产"资源的 CRUD (创建、读取、更新、删除) API 端点。
- API 端点受权限保护，只有特定角色（如主管）才能调用。
- 支持通过 API 进行设备主数据的批量导入。

#### 故事 1.4: (移动端) 发起维修请求

**作为一个** 一线员工,

**我想要** 使用移动应用扫描设备码，填写一个包含故障表现、图片和优先级的表单来提交维修请求,

**以便于** 我可以快速、准确、客观地报告设备故障表现。

**验收标准**:

- 用户可以在移动应用上成功登录。
- 应用可以通过摄像头扫描资产二维码，并调用 API 获取设备信息（包括其常规位置）自动填充表单。
- 用户必须从预设的故障表现列表中选择一个或多个故障现象（如：设备停机、断电、异常噪音、漏油漏液等）。
- 设备位置信息从设备主数据自动获取并显示，用户无需手动输入。
- 用户可以选填一段文字作为补充报修内容。
- 用户可以从相册选择或现场拍摄一张照片并附加到表单中，并支持在照片上进行简单的圈点标注。
- 用户可以为该维修请求选择一个预设的优先级（低、中、高），紧急优先级仅在勾选"造成生产中断"时可选。
- 成功提交后，系统在数据库中创建一条新的工单记录，初始状态为"待处理"。

### 史诗 2: 工单管理与处理

**目标**: 这个史诗的核心目标是为维修技术员和主管提供一个完整的工单处理闭环。当这个史诗完成后，一个报修单从被创建开始，可以被顺利地指派、接收、处理、更新，直到最终完成归档，整个过程都在线上清晰可见。

#### 故事 2.1: 工单分配与通知

**作为一个** 设备部门主管,

**我想要** 系统能根据预设规则（如设备、区域、类别）自动分配新工单，并支持我手动调整,

**以便于** 提升派工效率，确保每个任务都有明确的负责人。

**验收标准**:

- 系统后台应提供一个简单的规则配置界面，用于设定自动派工的条件。
- 当新报修请求符合规则时，系统自动将其分配给指定的技术员。
- 被分配的技术员会收到新任务的通知。
- 主管可以在 Web 管理端手动将工单指派或改派给任何技术员。

#### 故事 2.2: (Web/移动端) 工单处理与状态更新

**作为一个** 维修技术员,

**我想要** 在我的任务列表中查看工单，并能在执行过程中随时更新其状态,

**以便于** 高效管理我的工作，并让所有相关人员了解最新进展。

**验收标准**:

- 技术员登录后，可以在 Web 端和移动端看到一个"我的任务"列表。
- 技术员可以打开工单详情，查看所有报修信息、设备历史和附加文档。
- 技术员可以将工单状态从"待处理"更新为"进行中"或"等待备件"等。
- 工单状态的任何变更都会被记录，并对主管可见。

#### 故事 2.3: (Web/移动端) 记录解决方案与完成工单

**作为一个** 维修技术员,

**我想要** 在维修完成后，方便地记录解决方案、填写故障代码并上传完成照片,

**以便于** 为设备建立完整的维护档案，并通知报修员工确认。

**验收标准**:

- 在工单详情页，技术员可以将工单标记为"已完成"。
- 标记完成时，需要填写解决方案描述、选择故障代码（可选）。
- 技术员可以上传维修完成后的照片作为证明。
- 工单标记为"已完成"后，等待报修员工确认关闭。

#### 故事 2.3.1: (移动端) 员工查看和关闭工单

**作为一个** 报修员工,

**我想要** 在移动端查看我创建的工单状态，并在维修完成后确认关闭工单,

**以便于** 我可以验证设备已修复并正式关闭报修流程。

**验收标准**:

- 员工可以在移动端"我的工单"列表中查看自己创建的所有工单。
- 员工只能看到自己创建的工单，不能看到其他员工的工单。
- 默认显示未关闭的工单（包括待处理、进行中、已完成状态）。
- 已关闭的工单默认隐藏，但可以通过筛选器查看。
- 当工单状态为"已完成"时，员工可以在工单详情页看到"关闭工单"按钮。
- 点击"关闭工单"后，工单状态变更为"已关闭"。
- 工单关闭后，所有相关信息自动归档到对应资产的维护历史中。

#### 故事 2.4: (Web) 工单创建功能 - 棕地功能增强

**作为一个** 维护员工或技术人员,

**我想要** 能够直接从 Web 界面创建工单,

**以便于** 我可以在不切换到移动应用的情况下报告设备问题，便于测试和工作流程的一致性。

**验收标准**:

**功能需求:**
- 在工单管理界面(工单管理界面)的右上角添加"创建工单"按钮
- 创建工单表单包含与移动应用界面一致的字段：
  - 设备选择(设备) - 必填，从设备主数据中选择
  - 标题(工单标题) - 必填，最少5个字符
  - 故障表现选择(故障表现) - 必填，多选，从预设故障现象列表选择
  - 位置字段(设备位置) - 从所选设备主数据自动获取，只读显示
  - 补充位置信息(补充位置) - 可选，用于特殊位置说明
  - 造成生产中断复选框 - 用于控制紧急优先级可用性
  - 优先级选择器(优先级): 低/中/高，紧急（仅在勾选生产中断时可选）
  - 描述字段(详细描述) - 可选
  - 照片上传选项(故障照片) - 可选
- 表单验证并提交到现有的 `POST /api/work-orders` 端点

**集成需求:**
- 现有工单管理功能继续正常工作，不受影响
- 新功能遵循现有的 Zustand 状态管理模式
- 与 work-order-service API 的集成保持当前行为

**质量需求:**
- 表单验证规则与移动应用保持一致
- 成功/错误消息与现有 Web 应用模式一致
- 现有工单列表和筛选功能无回归问题

**技术说明**:
- **集成方式**: 在现有 WorkOrderManagement 组件中添加模态框/抽屉模式的工单创建功能
- **现有模式参考**: 移动端 Flutter WorkOrderFormScreen.dart 提供字段结构和验证规则
- **关键约束**: 必须重用现有的 work-order-service API 端点，遵循已建立的 Zustand 存储模式

**完成定义**:
- [x] 在 WorkOrderManagement 组件头部添加"创建工单"按钮
- [x] 实现包含所有必填字段的工单创建表单
- [x] 实现与移动应用规则匹配的表单验证
- [x] 与现有 work-order-store 和 work-order-service 集成
- [x] 带有用户反馈的成功/错误处理
- [x] 验证现有工单管理功能保持不变
- [x] UI 遵循现有设计模式和中文本地化

### 史诗 3: KPI 仪表板与管理视图

**目标**: 这个史诗的目标是为管理者赋能。我们将利用前两个史诗积累的数据，构建一个强大的数据可视化和管理中心。完成后，主管不仅能宏观掌握维护工作的整体态势，还能对用户和设备等主数据进行日常管理。

#### 故事 3.1: KPI 仪表板数据可视化

**作为一个** 设备部门主管,

**我想要** 在 Web 应用首页看到一个清晰、可视化的 KPI 仪表板,

**以便于** 我可以快速理解当前的工作负载、团队效率和整体资产健康状况。

**验收标准**:

- Web 应用的主管视图首页即为 KPI 仪表板。
- 仪表板必须包含"工单指标"模块，例如使用饼图展示不同状态的工单分布。
- 仪表板必须包含"时间指标"模块，展示关键指标如 MTTR。
- 仪表板必须包含"资产中心指标"模块，例如展示总停机时间最长的前 5 个设备。
- 仪表板上的所有数据需接近实时更新。

#### 故事 3.2: 工单列表的高级筛选与查询

**作为一个** 设备部门主管,

**我想要** 能够通过多种条件（如状态、负责人、设备、日期范围）来筛选和搜索所有的工单,

**以便于** 我可以进行深入的分析和问题追溯。

**验收标准**:

- 提供一个工单管理页面，以列表形式展示所有工单。
- 列表上方提供搜索框和多个筛选条件。
- 筛选结果可以被导出为 CSV 文件。

#### 故事 3.3: (Web) 用户与设备主数据管理

**作为一个** 设备部门主管,

**我想要** 一个简单的 Web 界面来管理用户和设备主数据,

**以便于** 我可以进行日常的人员调配和设备信息更新。

**验收标准**:

- 系统提供一个"用户管理"页面，主管可以对用户进行 CRUD 及角色分配。
- 系统提供一个"设备管理"页面，主管可以对设备资产进行 CRUD。
- 所有管理操作都受权限保护，仅主管及以上角色可访问。

### 史诗 4: Web 端用户登录界面

**目标**: 这个史诗的目标是为 Web 应用实现完整的用户登录和认证流程。虽然后端认证 API 已在史诗 1 中实现，但 Web 端仍缺少登录界面。完成后，用户将能够通过 Web 界面安全登录系统，根据其角色访问相应功能。

#### 故事 4.1: 登录页面实现

**作为一个** 系统用户（员工、技术员、主管、管理员）,

**我想要** 通过一个专门的登录页面输入我的凭证进行身份验证,

**以便于** 我可以安全地访问系统并使用与我角色相关的功能。

**验收标准**:

- 创建 `/login` 路由和登录页面组件。
- 页面包含邮箱/用户名和密码输入框，使用 ShadCN/UI 组件。
- 实现表单验证，确保必填字段不为空。
- 登录按钮在请求期间显示加载状态。
- 登录失败时显示清晰的错误消息（如"用户名或密码错误"）。
- 登录成功后自动跳转到 dashboard 页面。

#### 故事 4.2: 认证流程集成

**作为一个** 前端开发人员,

**我想要** 实现一个完整的认证流程，包括 token 管理和状态维护,

**以便于** 系统能够安全地处理用户会话并在后续请求中自动附加认证信息。

**验收标准**:

- 创建 `auth-service.ts` 服务，封装对后端 `/api/auth/login` 端点的调用。
- 创建 `auth-store.ts` 使用 Zustand 管理用户认证状态。
- JWT token 安全存储在 localStorage 中（后续可升级为 httpOnly cookies）。
- API 客户端自动在请求头中附加 Bearer token。
- 实现 token 过期检测和自动清理机制。
- 提供登出功能，清理 token 和用户状态。

#### 故事 4.3: 路由保护和用户界面集成

**作为一个** 系统用户,

**我想要** 系统能够根据我的登录状态自动控制页面访问权限,

**以便于** 未登录用户无法访问受保护的页面，同时我能够看到自己的登录状态。

**验收标准**:

- 创建认证检查的布局组件，保护 `/dashboard` 路由。
- 未登录用户访问受保护页面时自动重定向到 `/login`。
- 登录后根据用户角色重定向到相应页面：
  - EMPLOYEE: `/dashboard/work-orders`
  - TECHNICIAN: `/dashboard/my-tasks`
  - SUPERVISOR/ADMIN: `/dashboard`
- 在导航栏显示当前登录用户的名称和角色。
- 导航栏包含"退出登录"按钮，点击后清理认证状态并返回登录页。
- 页面刷新后保持登录状态（读取存储的 token）。
